# Validation functions
#
# End goal: An individual validation function for each database
# table, and a single wrapper function called `validate(table = 'arg')`
# (or similar) that can then call any of the individual table
# validation functions via a 'table' arg.

#' Validate acoustic_animals data
#'
#' @description `validate_acoustic_animals` scans the output of
#' `prep_otn_tagging` and flags any tag-related errors it finds.
#'
#' @details `prep_otn_tagging` prepares OTN tag sheet data for
#' ingestion into the SOMNI database. The most important output of that
#' is the `acoustic_animals` table, which links each unique animal
#' to a unique acoustic tag. This table is ultimately used to link
#' receiver detections to an animal in the database. As such, it's
#' important to ensure the integrity of your tag metadata!
#'
#' This function validates tag metadata in three ways: first, it ensures
#' the required tag parameters (either tag serial number, `tag_serial`,
#' OR the full Vue tag ID, `vue_tag_id`) are present in the data.
#'
#' Second, it scans tag sheets to ensure all tags have a match in the
#' database. This is helpful for flagging any serial numbers or IDs that
#' may have typos in them. In order to take full advantage of this, a
#' database connection must be provided in the `db` arg of the function.
#' If you have any tag sheets that you have processed with `prep_tag_sheet`
#' but not yet imported into the database, they can be provided as a
#' dataframe via the `tags` arg.
#'
#' Finally, if provided an active database connection via `db`, this
#' function checks if any tags you are validating are already paired with
#' another animal in the database. This means the tag ID you have provided
#' is either a typo OR comes from an animal that has been recaptured,
#' and the tag is now being re-used. Remember, a tag cannot be in two
#' animals at once! This will only cause errors in your detection data if
#' recaptures are not properly updated in the database.
#'
#' @param dat A dataframe of `acoustic_animals` data; typically from the output of `prep_otn_tagging`.
#' @param tags A dataframe of `metadata_acoustictags` data that is not yet in the database to supplement error scanning; typically the output of `prep_tag_sheet`.
#' @param db Name of SOMNI database connection object in R workspace. Defaults to "db".
#'
#' @return A tibble containing all errors flagged.
#' @export
#'
#' @examples
#' \dontrun{
#' tm <- readxl::read_excel("OTN_tagging_sheet.xslx", sheet = "Tag Metadata")
#' prepped_otn <- prep_otn_tagging(tm, db = db)
#' validate_acoustic_animals(prepped_otn$acoustic_animals)
#' }
validate_acoustic_animals <- function(dat, # acoustic_animals dataframe
                                 tags = NA, # optional - dataframe containing tags that haven't been uploaded to db yet
                                 db = db) {
  aa <- dat # acoustic_animals

  options(warn = 1)

  # Create empty "errors" df
  # Add to errors table as they come up
  errors <- data.frame(matrix(ncol = 4, nrow = 0))
  colnames(errors) <- c("Table", "Record ID", "Column name", "Error")

  # Check if db connection is provided. Can't perform full validation without it.
  if (!missing(db)) {

    # Check that SOMNI IDs are unique
    somni_ids <- DBI::dbGetQuery(db, "select distinct(somni_id) from metadata_animals;")
    bad_ids <- aa[["somni_id"]][aa$somni_id %in% somni_ids]
    bad_ids <- toString(shQuote(bad_ids))
    if ((length(bad_ids) > 0) & (bad_ids != "")) warning("The following somni_ids that were generated by prep_otn_tagging are already present in the database. Data may have been added to the database since you last ran this script. Try refreshing your database connection and running prep_otn_tagging once again. Bad ids:",
                                                         bad_ids)

    # Pull all tags already in acoustic_animals
    aa_tags <- DBI::dbGetQuery(db, "select animal_tag, somni_id, vue_tag_id, vue_id, tag_serial from acoustic_animals;")

    # Check that animal_tag record IDs are unique
    bad_ids <- aa[["animal_tag"]][aa$animal_tag %in% aa_tags$animal_tag]
    bad_ids <- toString(shQuote(bad_ids))
    if ((length(bad_ids) > 0) & (bad_ids != "")) warning("The following animal_tag record IDs that were generated by prep_otn_tagging are already present in the database. Data may have been added to the database since you last ran this script. Try refreshing your database connection and running prep_otn_tagging once again. Bad ids:",
                                                         bad_ids)

    # Check that tags aren't already in use in animal_tags
    # Otherwise it's a typo OR the tag is from a recaptured animal
    used_tags <- aa[["vue_tag_id"]][aa$vue_tag_id %in% aa_tags$vue_tag_id & !is.na(aa$vue_tag_id)]
    if (length(used_tags) > 0) {
      #warning(length(used_tags), " record(s) have Vue tag IDs already in use in the database.")
      bad_records <- aa[aa$vue_tag_id %in% used_tags,c("animal_tag")]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id", paste("Vue tag ID", used_tags[i], "already in use in the database. If you are sure it is the correct tag ID and not a typo, perhaps this tag comes from a recaptured animal?"))
      }
    }
    used_tags <- aa[["tag_serial"]][aa$tag_serial %in% aa_tags$tag_serial & !is.na(aa$tag_serial)]
    if (length(used_tags) > 0) {
      #warning(length(used_tags), " record(s) have tag serials already in use in the database.")
      bad_records <- aa[aa$tag_serial %in% used_tags,c("animal_tag")]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "tag_serial", paste("Tag serial", used_tags[i], "already in use in the database. If you are sure it is the correct tag serial and not a typo, perhaps this tag comes from a recaptured animal?"))
      }
    }

    # Pull all metadata_acoustictags data
    tag_list <- DBI::dbGetQuery(db, "select serial_number, vue_tag_id from metadata_acoustictags;")
    x <- sapply(tag_list$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tag_list$code_space <- x[1,]
    tag_list$vue_id <- x[2,]

  } else if (!missing(tags)) {
    warning("No active database connection was provided. Data validation will be limited in scope. Advanced tag validation (e.g. checking for invalid serial numbers, code spaces, or vue tag IDs) will only be performed with the 'tags' dataframe provided.")
  } else {
    warning("No active database connection or 'tags' dataframe was provided. Data validation will be limited in scope. Advanced tag validation (e.g. checking for invalid serial numbers, code spaces, or vue tag IDs) will not be performed.")
  }

  # If database connection was provided AND tags dataframe provided,
  # merge the two vetting dataframes together
  if (!missing(tags)) {
    x <- sapply(tags$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tags$code_space <- x[1,]
    tags$vue_id <- x[2,]
    if (!missing(db)) {
      tag_list <- rbind(tag_list, tags[,c("serial_number", "vue_tag_id", "code_space", "vue_id")])
    } else {
      tag_list <- tags[,c("serial_number", "vue_tag_id", "code_space", "vue_id")]
    }
  }

  # Baseline tag validation checks
  # The main rule is: either the serial number OR the vue_tag_id must be provided.
  if (nrow(aa[is.na(aa$tag_serial) & is.na(aa$vue_tag_id),]) > 0) {
    #warning(nrow(aa[is.na(aa$tag_serial) & is.na(aa$vue_tag_id),]), " records have a NULL tag_serial AND vue_tag_id. These records cannot be entered into the database.")
    bad_records <- aa[is.na(aa$tag_serial) & is.na(aa$vue_tag_id),]
    for (i in 1:length(bad_records)) {
      errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "tag_serial & vue_tag_id", "Missing both tag_serial AND vue_tag_id. One or the other MUST be provided. These records cannot be entered into the acoustic_animals database table otherwise. Information about the animal can still be stored in metadata_animals, however.")
    }
  }

  if (nrow(aa[is.na(aa$tag_serial) & !is.na(aa$vue_tag_id),]) > 0) {
    #warning(sum(is.na(aa$tag_serial)), " records have NA serial numbers.")
    bad_records <- aa[is.na(aa$tag_serial) & !is.na(aa$vue_tag_id), c("animal_tag")]
    for (i in 1:length(bad_records)) {
      errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "tag_serial", "Missing tag serial number. Not required if vue_tag_id is provided, but highly recommended.")
    }
  }

  if (nrow(aa[!is.na(aa$tag_serial) & is.na(aa$vue_tag_id) & is.na(aa$vue_id),]) > 0) {
    #warning(sum(is.na(aa$vue_tag_id)), " records have NA Vue tag IDs.")
    bad_records <- aa[!is.na(aa$tag_serial) & is.na(aa$vue_tag_id) & is.na(aa$vue_id), c("animal_tag")]
    for (i in 1:length(bad_records)) {
      errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id & vue_id", "Missing vue_tag_id (e.g. 'A69-9001-9374') and vue_id ('9374'). Neither is required if serial number is provided, but highly recommended. If you do not know the full code space (e.g. 'A69-9001'), providing simply the vue_id (e.g., '9374') is helpful.")
    }
  }

  # Flag if any tags are duplicated
  # Duplicated serial numbers
  if (any(table(aa$tag_serial)>1)) {
    dupes <- data.frame(table(aa$tag_serial))
    dupes <- dupes[dupes$Freq > 1,]
    for (i in 1:nrow(dupes)) {
      dupes_sn <- dupes[i,1]
      bad_records <- aa[["animal_tag"]][aa$tag_serial == dupes_sn]
      errors[nrow(errors)+1,] <- c("acoustic_animals", toString(bad_records), "tag_serial", paste("Tag serial", dupes_sn, "duplicated."))
    }
  }

  # Duplicated vue_tag_ids
  if (any(table(aa$vue_tag_id)>1)) {
    dupes <- data.frame(table(aa$vue_tag_id))
    dupes <- dupes[dupes$Freq > 1,]
    for (i in 1:nrow(dupes)) {
      dupes_sn <- dupes[i,1]
      bad_records <- aa[["animal_tag"]][aa$vue_tag_id == dupes_sn]
      errors[nrow(errors)+1,] <- c("acoustic_animals", toString(bad_records), "vue_tag_id", paste("Vue tag ID", dupes_sn, "duplicated."))
    }
  }

  # More complex tag checks
  # Set text to indicate which data vetting sources were used for messages
  tag_src <- if (missing(tags) & !missing(db)) {
    "database"
  } else if (!missing(tags) & !missing(db)) {
    "provided 'tags' dataframe or the database"
  } else if (!missing(tags) & missing(db)) {
    "provided 'tags' dataframe"
  }

  # Check if both 'db' and 'tags' args are missing
  # If one or the other was provided, continue tag data validation
  if (missing(db) & missing(tags)) {

    # This is done in a more sophisticated way below if db or tags provided
    if (nrow(aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial),]) > 0) {
      missing_full_tag_id <- aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial),]
      message(nrow(missing_full_tag_id), " record(s) have a vue_id and tag_serial, but not a full vue_tag_id (e.g. 'A69-9001-9285'). Running fill_tag_id() could help fill those in automatically.")
      bad_records <- missing_full_tag_id[["animal_tag"]]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id", "Missing full vue_tag_id (e.g. 'A69-9001-9375'). Running fill_tag_id() could help fill this in automatically.")
      }
    }
  } else {
    # Now run any advanced tag-related data checks

    # Check that the tag serial numbers & vue IDs are actually in tag_list
    bad_sns <- aa[["tag_serial"]][!(aa$tag_serial %in% tag_list$serial_number) & !is.na(aa$tag_serial)]
    bad_vue <- aa[["vue_id"]][!(aa$vue_id %in% tag_list$vue_id) & !is.na(aa$vue_id)]
    bad_vue_id <- aa[["vue_tag_id"]][!(aa$vue_tag_id %in% tag_list$vue_tag_id) & !is.na(aa$vue_tag_id)]

    # Tag serial NOT in tag_list but vue id IS
    if (nrow(aa[aa$tag_serial %in% bad_sns & !(aa$vue_id %in% bad_vue),]) > 0) {
      bad_records <- aa[aa$tag_serial %in% bad_sns & !(aa$vue_id %in% bad_vue),]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "tag_serial", paste0("Tag serial ", bad_records[i,"tag_serial"], " is likely a typo. This tag is not present in the ", tag_src, " but full vue_tag_id exists. The function find_tag_errors() can help resolve any typos."))
      }
    }

    # Tag vue_id NOT in tag_list but serial IS
    if (nrow(aa[!(aa$tag_serial %in% bad_sns) & aa$vue_id %in% bad_vue,]) > 0) {
      bad_records <- aa[!(aa$tag_serial %in% bad_sns) & aa$vue_id %in% bad_vue,]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "vue_id", paste0("Vue ID ", bad_records[i,"vue_id"], " not present in the ", tag_src, " but serial number exists. Tag Vue ID is likely a typo. The function find_tag_errors() can help resolve any typos."))
      }
    }

    # Tag serial and vue ID are both in database, but vue_tag_id is not
    if (nrow(aa[!(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue) & aa$vue_tag_id %in% bad_vue_id,]) > 0) {
      bad_records <- aa[!(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue) & aa$vue_tag_id %in% bad_vue_id,]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "vue_tag_id", paste0("Code space typo in ", bad_records[i,"vue_tag_id"], " but valid tag_serial-vue_id combo. The function fill_tag_id() can fill in the full tag ID with the correct code space."))
      }
    }

    # Neither tag serial nor vue id in tag_list = missing or bad tag data
    if (nrow(aa[aa$tag_serial %in% bad_sns & aa$vue_id %in% bad_vue,]) > 0) {
      bad_records <- aa[aa$tag_serial %in% bad_sns & aa$vue_id %in% bad_vue,]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "tag_serial & vue_id", paste0("The tag_serial-vue_id combination of ", bad_records[i,"tag_serial"], " & ", bad_records[i,"vue_id"], " does not exist. Either both are incorrect or new tag sheets need to be imported."))
      }
    }

    # Tag serial and vue ID are both in database, but vue_tag_id is empty
    if (nrow(aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial) & !(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue),]) > 0) {
      missing_full_tag_id <- aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial) & !(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue),]
      message(nrow(missing_full_tag_id), " record(s) have a valid vue_id and tag_serial, but not a full vue_tag_id (e.g. 'A69-9001-9285'). Running fill_tag_id() could help fill those in automatically.")
      bad_records <- missing_full_tag_id[["animal_tag"]]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id", "Missing full vue_tag_id (e.g. 'A69-9001-9375'). Running fill_tag_id() could help fill this in automatically.")
      }
    }

    if (length(bad_sns) + length(bad_vue) + length(bad_vue_id) > 0 & length(bad_sns) < 10) {
      message("Some of your tag serial numbers and/or Vue ID codes and/or full tag IDs cannot be matched to an existing tag in the ", tag_src, ". This could be due to a typo in either the serial number or the vue id. The function `find_tag_errors()` could potentially help resolve any issues.")
    } else if (length(bad_sns) >= 10 & !missing(db)) {
      message("More than 10 of your records contain tag serials that are missing from the ", tag_src, ". This most likely means you need to find the associated tag sheets for these tags. Re-try validation after running `prep_tag_sheets()` on the new tags and providing the output to this function.")
    } else if (length(bad_sns) >= 10 & missing(db)) {
      message("More than 10 of your records contain tag serials that are missing from the ", tag_src, ". Try re-running the validation with an active database connection to check if these tags are already in the database.")
    }

  }

  if (nrow(errors) > 0) {
    return(tibble::as_tibble(errors))
  } else {
    message("Hooray! Your data passes all validation checks.")
  }

}


#' Fill in full Vue Tag ID
#'
#' @description If you have empty `vue_tag_id` values in your
#' `acoustic_animals` dataframe, you can use `fill_tag_id` to
#' find and populate `vue_tag_id` using the `vue_id` and
#' `tag_serial` columns. Any existing `vue_tag_id` values are
#' not modified.
#'
#' @details Each complete tag ID (e.g., 'A69-9001-3945') has a unique
#' Vue ID and tag serial. Provided you have the Vue ID and serial
#' number, in addition to the original tag purchase sheets, you
#' can easily look up the complete tag ID.
#'
#' @param dat A dataframe of `acoustic_animals` data; typically from the output of `prep_otn_tagging`.
#' @param tags A dataframe of `metadata_acoustictags` data that is not yet in the database to supplement tag lookups; typically the output of `prep_tag_sheet`.
#' @param db Name of SOMNI database connection object in R workspace. Defaults to "db".
#' @param overwrite Should the vue_tag_id column be overwritten? By default, only NULL vue_tag_id records are updated. Change to `overwrite = TRUE` to update all tags in the vue_tag_id column.
#'
#' @return A dataframe that matches the input `dat` dataframe, but with the `vue_tag_id` column populated.
#' @export
#'
#' @examples
#' \dontrun{
#' tm <- readxl::read_excel("OTN_tagging_sheet.xslx", sheet = "Tag Metadata")
#' prepped_otn <- prep_otn_tagging(tm, db = db)
#' fill_tag_id(prepped_otn$acoustic_animals, db = db)
#' }
fill_tag_id <- function(dat,
                        tags = NA,
                        db = db,
                        overwrite = F) {
  aa <- dat
  if (missing(tags) & missing(db)) stop("This function must be provided tag sheets or a database connection to function.")

  # If db connection provided, pull all tag info
  if (!missing(db)) {
    tag_list <- DBI::dbGetQuery(db, "select serial_number, vue_tag_id from metadata_acoustictags;")
    x <- sapply(tag_list$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tag_list$vue_id <- x[2,]
  }

  # If database connection was provided AND tags dataframe provided,
  # merge the two vetting dataframes together
  if (!missing(tags)) {
    x <- sapply(tags$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tags$vue_id <- x[2,]
    if (!missing(db)) {
      tag_list <- rbind(tag_list, tags[,c("serial_number", "vue_tag_id", "vue_id")])
    } else {
      tag_list <- tags[,c("serial_number", "vue_tag_id", "vue_id")]
    }
  }

  names(tag_list)[1] <- "tag_serial"

  if (overwrite) {
    aa$vue_tag_id <- NA
    fill <- aa[["animal_tag"]][!is.na(aa$tag_serial) & !is.na(aa$vue_id)]
  } else {
    fill <- aa[["animal_tag"]][is.na(aa$vue_tag_id) & !is.na(aa$tag_serial) & !is.na(aa$vue_id)]
  }

  tag_ids <- merge(aa[aa$animal_tag %in% fill, c("animal_tag", "vue_id", "tag_serial")], tag_list, by = c("tag_serial", "vue_id"))

  aa[["vue_tag_id"]][match(tag_ids$animal_tag, aa$animal_tag)] <- tag_ids$vue_tag_id
  message("Updated ", nrow(tag_ids), " vue_tag_id records!")
  return(aa)
}


#' Find tag typos and suggest fixes
#'
#' `find_tag_errors` will take your `acoustic_animals` dataframe,
#' compare the serial number-tag ID combinations therein to the
#' database and/or provided list of tag metadata, then run through
#' a series of logic statements to find any mismatches between
#' tag serial number and tag ID. It will then suggest the most
#' likely fix for either serial number or ID.
#'
#' @details Every tag provided by Vemco/Innovasea has a unique
#' serial number-tag ID combination, and that is used to find any errors
#' in tag data. The function first runs a quick test to see if this combo
#' is valid - if it is, the tag most likely was the correct tag in cases
#' where the serial number was duplicated in `acoustic_animals`.
#' Alternatively, if the combo is valid and no duplicates were in
#' `acoustic_animals`, the code space (e.g. 'A69-9001') simply needed to be
#' updated.
#'
#' Next, the function filters down to any remaining tags where the serial
#' number-vue ID combo is invalid. In these cases, either the serial number
#' or vue id (or both) are incorrect. The function then performs a table
#' join on first the original serial number ('orig_sn'), then on the
#' original vue ID ('orig_vid') and compares the results.
#'
#' If the serial number is correct, but the vue ID is not, the join returns
#' a list of possible vue IDs ('possible_vid'). And vice versa, if the vue
#' ID is correct, the function returns a list of possible serial numbers
#' ('possible_sn').
#'
#' Finally, the possible combinations of new serial numbers and vue IDs are
#' tested for validity. If the new serial number-vue ID combos are valid,
#' the suggested combination is provided with a description of what was
#' updated in the 'fix' column.
#'
#' The full output table includes the results of all these joins. It is
#' organized as follows:
#' * `record_id` indicates which `animal_tag` record is being
#' tested from the original `acoustic_animals` dataframe.
#' * `sn_vid` is a concatenation of the original serial number and vue id.
#' * `valid_combo` indicates whether the `sn_vid` tag combination exists.
#' * `orig_sn`, `orig_vid`, `orig_tag` stand for the original serial, vue ID, and full tag ID that were provided in the `acoustic_animals` dataset.
#' * `matching_sn`, `possible_vid`, `matching_sn_tag` is tag data that was matched to the original tag based on the `orig_sn`.
#' * `possible_sn`, `matching_vid`, `matching_vid_tag` is tag data that was matched to the original tag based on the `orig_vid`.
#' * `suggested_sn`, `suggested_vid`, `suggested_tag` is the suggested tag data after testing that the serial-ID combination is valid.
#' * `sn_vid_new` and `new_valid` are the new serial number-vue ID combination and validity of that combination with the suggested tag fixes.
#' * `freq` indicates if any of the suggested tag fixes resulted in a duplicated tag.
#' * `fix` Describes the suggested fix to the original tag data that needs to be made to fix any invalid tags.
#'
#' The truncated output only includes the `record_id`, original tag data,
#' suggested tag fixes, and the `fix` column describing the fix.
#'
#' @param dat A dataframe of `acoustic_animals` data; typically from the output of `prep_otn_tagging`.
#' @param tags A dataframe of `metadata_acoustictags` data that is not yet in the database to supplement tag lookups; typically the output of `prep_tag_sheet`.
#' @param db Name of SOMNI database connection object in R workspace. Defaults to "db".
#' @param full_output Boolean (T/F). Do you want to see the full output of the table joins between the provided data and the tags data?
#'
#' @return A dataframe containing original tag data and suggested fixes.
#' @export
#'
#' @examples
#' \dontrun{
#' find_tag_errors(ft$acoustic_animals, tags = tags, db = db)
#' }
find_tag_errors <- function(dat,
                            tags = NA,
                            db = db,
                            full_output = F) {
  if (missing(db) & missing(tags)) stop("This function needs either a list of tags or access to the database to function!")
  if (missing(db)) warning("Tag error checking will be limited in scope without access to the full list of tags in the database!")
  if (class(dat) == 'list') {
    aa <- dat[["acoustic_animals"]]
  } else {
    aa <- dat
  }

  # If db connection provided, pull all tag info
  if (!missing(db)) {
    tag_list <- DBI::dbGetQuery(db, "select serial_number, vue_tag_id from metadata_acoustictags;")
    x <- sapply(tag_list$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tag_list$vue_id <- x[2,]
  }

  # If database connection was provided AND tags dataframe provided,
  # merge the two vetting dataframes together
  if (!missing(tags)) {
    x <- sapply(tags$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tags$vue_id <- x[2,]
    if (!missing(db)) {
      tag_list <- rbind(tag_list, tags[,c("serial_number", "vue_tag_id", "vue_id")])
    } else {
      tag_list <- tags[,c("serial_number", "vue_tag_id", "vue_id")]
    }
  }

  names(tag_list)[1] <- "tag_serial"

  errors <- suppressWarnings(suppressMessages(validate_acoustic_animals(aa, tags = tags, db = db)))

  if (is.null(errors)) return(message("All tags are valid!"))

  tmp <- stringr::str_c(errors$`Record ID`, collapse = ", ")
  tmp <- as.numeric(unlist(strsplit(tmp, ", ")))
  tmp <- sort(unique(tmp))

  out <- data.frame(matrix(nrow = length(tmp), ncol = 1, data = tmp, dimnames = list(NULL,"record_id")))
  out <- merge(out, aa[,c("animal_tag", "vue_tag_id", "vue_id", "tag_serial")], by.x = "record_id", by.y = "animal_tag", all.x = T)
  names(out) <- c("record_id", "orig_tag", "orig_vid", "orig_sn")
  out$matching_vid <- out$orig_vid
  out$matching_sn <- out$orig_sn
  out <- merge(out, tag_list, by.x = "matching_vid", by.y = "vue_id", all.x = TRUE)
  names(out)[grep("serial", names(out))] <- "possible_sn"
  names(out)[grep("vue_tag_id", names(out))] <- "matching_vid_tag"
  out <- merge(out, tag_list, by.x = "matching_sn", by.y = "tag_serial", all.x = TRUE)
  names(out)[grep("vue_tag_id", names(out))] <- "matching_sn_tag"
  names(out)[grep("vue_id", names(out))] <- "possible_vid"

  out$sn_vid <- paste0(out$orig_sn, "-", out$orig_vid)
  tag_list$sn_vid <- paste0(tag_list$tag_serial, "-", tag_list$vue_id)
  out$valid_combo <- out$sn_vid %in% tag_list$sn_vid

  out <- out %>% dplyr::select(record_id, sn_vid, valid_combo, orig_sn, orig_vid, orig_tag, matching_sn, possible_vid, matching_sn_tag, possible_sn, matching_vid, matching_vid_tag)

  # Assume all valid sn-vid combo tags are either:
  # 1) the correct duplicate out of dupe SN pairs
  # or 2) need to get an updated code space
  out[["suggested_sn"]][out$valid_combo == TRUE] <- out[["orig_sn"]][out$valid_combo == TRUE]
  out[["suggested_vid"]][out$valid_combo == TRUE] <- out[["orig_vid"]][out$valid_combo == TRUE]
  out[["suggested_tag"]][out$valid_combo == TRUE] <- out[["matching_sn_tag"]][out$valid_combo == TRUE]
  out[["fix"]][out$valid_combo == TRUE] <- ifelse(out$orig_tag[out$valid_combo == TRUE] == out$suggested_tag[out$valid_combo == TRUE],
                                                  "No fix; tag correct",
                                                  "Update code space")

  # IF sn-vid combo is FALSE, AND the possible_vid option is NA,
  # => This indicates a bad orig_sn.
  # However, in cases where orig_sn was duplicated,
  # possible_vid won't be NA! The orig_sn is correct, just duplicated.
  # => This indicates bad orig_sn with good orig_vid.
  # So, we need sn_vid combo == FALSE,
  # AND possible_vid == NA,
  # OR simply sn_vid == FALSE & orig_vid == matching_vid
  # To confidently suggest updating to possible_sn.
  # Otherwise update to NA... unsure what it should be
  out$suggested_sn[out$valid_combo == FALSE] <-
    ifelse(is.na(out$possible_vid[out$valid_combo == FALSE])
           & !is.na(out$possible_sn[out$valid_combo == FALSE])
           | out$orig_vid[out$valid_combo == FALSE] == out$matching_vid[out$valid_combo == FALSE],
           out$possible_sn[out$valid_combo == FALSE], # Update suggested_sn to possible_sn if criteria met
           out$orig_sn[out$valid_combo == FALSE]) # Update suggested_sn to orig_sn if criteria not met

  # Same ifelse test as above, but to update the suggested_vid column
  out$suggested_vid[out$valid_combo == FALSE] <-
    ifelse(is.na(out$possible_vid[out$valid_combo == FALSE])
           & !is.na(out$possible_sn[out$valid_combo == FALSE])
           | out$orig_vid[out$valid_combo == FALSE] == out$matching_vid[out$valid_combo == FALSE],
           out$orig_vid[out$valid_combo == FALSE], # Update suggested_vid to orig_vid if criteria met
           out$matching_vid[out$valid_combo == FALSE]) # Update suggested_vid to matching_vid if criteria not met

  # Same ifelse test as above, but to update the suggested_tag column
  out$suggested_tag[out$valid_combo == FALSE] <-
    ifelse(is.na(out$possible_vid[out$valid_combo == FALSE])
           & !is.na(out$possible_sn[out$valid_combo == FALSE])
           | out$orig_vid[out$valid_combo == FALSE] == out$matching_vid[out$valid_combo == FALSE],
           out$matching_vid_tag[out$valid_combo == FALSE], # Update suggested_tag to matching_vid_tag (because serial number was incorrect but vid was correct) if criteria met
           out$matching_sn_tag[out$valid_combo == FALSE]) # Update suggested_vid to matching_sn_tag if criteria not met

  # Same ifelse test as above, but to update the fix column
  out$fix[out$valid_combo == FALSE] <-
    ifelse(is.na(out$possible_vid[out$valid_combo == FALSE])
           & !is.na(out$possible_sn[out$valid_combo == FALSE])
           | out$orig_vid[out$valid_combo == FALSE] == out$matching_vid[out$valid_combo == FALSE],
           "Update serial number", # Update fix column describing change
           "Update vue ID") # Update fix to vue ID if criteria not met

  # Now create a new sn-vid combo column to test if the fixes are valid
  out$sn_vid_new <- paste0(out$suggested_sn, "-", out$suggested_vid)
  out$new_valid <- out$sn_vid_new %in% tag_list$sn_vid

  # Next check if any duplicates were created
  out <- merge(out, plyr::count(out$sn_vid_new), by.x = "sn_vid_new", by.y = "x", all.x = TRUE)

  # Update fix column for any tags that are no good
  out[["fix"]][out$new_valid == FALSE] <- "Tag fix failed. Both serial and vue ID may be incorrect."
  out[["fix"]][out$freq > 1] <- "Tag fix failed. Duplicate tags remaning. Both serial and vue ID may be incorrect."

  out <- out %>% dplyr::select(record_id:suggested_tag, sn_vid_new, new_valid, freq, fix)

  if (full_output == TRUE) {
    return(out)
  } else {
    return(out[,c("record_id", "orig_sn", "orig_vid", "orig_tag", "suggested_sn", "suggested_vid", "suggested_tag", "fix")])
  }
}


#' Validate data for database import
#'
#' This function takes a supplied dataframe and a database table
#' to check that:
#' 1) the column names of the dataframe match the column names of the database table
#' 2) all non-NULL columns have no NULL values
#' 3) all column data types of the dataframe match the column data types of the database table
#'
#' @param dat A dataframe containing data to be appended to a SOMNI db table.
#' @param tbl The name of a SOMNI db table (e.g., "metadata_acoustictags" or "deployments_retrievals").
#'
#' @return Warnings if any validation checks fail
#' @export
#'
#' @examples
#' \dontrun{
#' tags <- prep_tag_sheet(raw_tag_dat)
#' validate_table(tags, "metadata_acoustictags")
#'
#' otn_tagging <- prep_otn_tagging(raw_otn_data)
#' validate_table(otn_tagging$metadata_animals, "metadata_animals")
#' }
validate_table <- function(dat, tbl) {
  # Check colnames match
  if (any(names(dat) != names(dt[[tbl]]))) warning("Column names in `dat` don't match column names in the database table `", tbl, "`.")

  # Check all required columns are not null
  non_nulls <- db_tbls[db_tbls$table_name == tbl & db_tbls$is_nullable == "NO",]
  for (i in non_nulls$column_name) {
    if (any(is.na(dat[[i]]))) {
      warning("Column ", i, " has null values. This column is not allowed to have null values in the database.")
    }
  }

  # Check dat coltypes match db coltypes
  coltypes <- unlist(dt[[tbl]], use.names = F)
  coltypes <- coltypes[coltypes != "POSIXt"] # Drop POSIXt
  coltypes[grep("geography", coltypes)] <- "character" # postgres geog columns will be eval'd as character
  coltypes[grep("integer64", coltypes)] <- "integer" # postgres integer64 columns will be eval'd as integer

  dat2 <- as.data.frame(Map(function(x, y) get(y)(x),
                             dat,
                             paste0("as.", coltypes)))

  if (!(any(dt[[tbl]] %in% sapply(dat2, class)))) warning("Some column types in `dat` don't match the column types of the database table `", tbl, "` in the database. See `data(dt)` to check column types in each db table.")
}
