# Validation functions
#
# End goal: An individual validation function for each database
# table, and a single wrapper function called `validate(table = 'arg')`
# (or similar) that can then call any of the individual table
# validation functions via a 'table' arg.

#' Validate acoustic_animals data
#'
#' @description `validate_acoustic_animals` scans the output of
#' `prep_otn_tagging` and flags any tag-related errors it finds.
#'
#' @details `prep_otn_tagging` prepares OTN tag sheet data for
#' ingestion into the SOMNI database. The most important output of that
#' is the `acoustic_animals` table, which links each unique animal
#' to a unique acoustic tag. This table is ultimately used to link
#' receiver detections to an animal in the database. As such, it's
#' important to ensure the integrity of your tag metadata!
#'
#' This function validates tag metadata in three ways: first, it ensures
#' the required tag parameters (either tag serial number, `tag_serial`,
#' OR the full Vue tag ID, `vue_tag_id`) are present in the data.
#'
#' Second, it scans tag sheets to ensure all tags have a match in the
#' database. This is helpful for flagging any serial numbers or IDs that
#' may have typos in them. In order to take full advantage of this, a
#' database connection must be provided in the `db` arg of the function.
#' If you have any tag sheets that you have processed with `prep_tag_sheet`
#' but not yet imported into the database, they can be provided as a
#' dataframe via the `tags` arg.
#'
#' Finally, if provided an active database connection via `db`, this
#' function checks if any tags you are validating are already paired with
#' another animal in the database. This means the tag ID you have provided
#' is either a typo OR comes from an animal that has been recaptured,
#' and the tag is now being re-used. Remember, a tag cannot be in two
#' animals at once! This will only cause errors in your detection data if
#' recaptures are not properly updated in the database.
#'
#' @param dat A dataframe of `acoustic_animals` data; typically from the output of `prep_otn_tagging`.
#' @param tags A dataframe of `metadata_acoustictags` data that is not yet in the database to supplement error scanning; typically the output of `prep_tag_sheet`.
#' @param db Name of SOMNI database connection object in R workspace. Defaults to "db".
#'
#' @return A tibble containing all errors flagged.
#' @export
#'
#' @examples
#' tm <- readxl::read_excel("OTN_tagging_sheet.xslx", sheet = "Tag Metadata")
#' prepped_otn <- prep_otn_tagging(tm, db = db)
#' validate_acoustic_animals(prepped_otn$acoustic_animals)
validate_acoustic_animals <- function(dat, # acoustic_animals dataframe
                                 tags = NA, # optional - dataframe containing tags that haven't been uploaded to db yet
                                 db = db) {
  aa <- dat # acoustic_animals

  options(warn = 1)

  # Create empty "errors" df
  # Add to errors table as they come up
  errors <- data.frame(matrix(ncol = 4, nrow = 0))
  colnames(errors) <- c("Table", "Record ID", "Column name", "Error")

  # Check if db connection is provided. Can't perform full validation without it.
  if (!missing(db)) {

    # Check that SOMNI IDs are unique
    somni_ids <- DBI::dbGetQuery(db, "select distinct(somni_id) from metadata_animals;")
    bad_ids <- aa[["somni_id"]][aa$somni_id %in% somni_ids]
    bad_ids <- toString(shQuote(bad_ids))
    if ((length(bad_ids) > 0) & (bad_ids != "")) warning("The following somni_ids that were generated by prep_otn_tagging are already present in the database. Data may have been added to the database since you last ran this script. Try refreshing your database connection and running prep_otn_tagging once again. Bad ids:",
                                                         bad_ids)

    # Pull all tags already in acoustic_animals
    aa_tags <- DBI::dbGetQuery(db, "select animal_tag, somni_id, vue_tag_id, vue_id, tag_serial from acoustic_animals;")

    # Check that animal_tag record IDs are unique
    bad_ids <- aa[["animal_tag"]][aa$animal_tag %in% aa_tags$animal_tag]
    bad_ids <- toString(shQuote(bad_ids))
    if ((length(bad_ids) > 0) & (bad_ids != "")) warning("The following animal_tag record IDs that were generated by prep_otn_tagging are already present in the database. Data may have been added to the database since you last ran this script. Try refreshing your database connection and running prep_otn_tagging once again. Bad ids:",
                                                         bad_ids)

    # Check that tags aren't already in use in animal_tags
    # Otherwise it's a typo OR the tag is from a recaptured animal
    used_tags <- aa[["vue_tag_id"]][aa$vue_tag_id %in% aa_tags$vue_tag_id & !is.na(aa$vue_tag_id)]
    if (length(used_tags) > 0) {
      #warning(length(used_tags), " record(s) have Vue tag IDs already in use in the database.")
      bad_records <- aa[aa$vue_tag_id %in% used_tags,c("animal_tag")]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id", paste("Vue tag ID", used_tags[i], "already in use in the database. If you are sure it is the correct tag ID and not a typo, perhaps this tag comes from a recaptured animal?"))
      }
    }
    used_tags <- aa[["tag_serial"]][aa$tag_serial %in% aa_tags$tag_serial & !is.na(aa$tag_serial)]
    if (length(used_tags) > 0) {
      #warning(length(used_tags), " record(s) have tag serials already in use in the database.")
      bad_records <- aa[aa$tag_serial %in% used_tags,c("animal_tag")]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "tag_serial", paste("Tag serial", used_tags[i], "already in use in the database. If you are sure it is the correct tag serial and not a typo, perhaps this tag comes from a recaptured animal?"))
      }
    }

    # Pull all metadata_acoustictags data
    tag_list <- DBI::dbGetQuery(db, "select serial_number, vue_tag_id from metadata_acoustictags;")
    x <- sapply(tag_list$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tag_list$code_space <- x[1,]
    tag_list$vue_id <- x[2,]

  } else if (!missing(tags)) {
    warning("No active database connection was provided. Data validation will be limited in scope. Advanced tag validation (e.g. checking for invalid serial numbers, code spaces, or vue tag IDs) will only be performed with the 'tags' dataframe provided.")
  } else {
    warning("No active database connection or 'tags' dataframe was provided. Data validation will be limited in scope. Advanced tag validation (e.g. checking for invalid serial numbers, code spaces, or vue tag IDs) will not be performed.")
  }

  # If database connection was provided AND tags dataframe provided,
  # merge the two vetting dataframes together
  if (!missing(tags)) {
    x <- sapply(tags$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tags$code_space <- x[1,]
    tags$vue_id <- x[2,]
    if (!missing(db)) {
      tag_list <- rbind(tag_list, tags[,c("serial_number", "vue_tag_id", "code_space", "vue_id")])
    } else {
      tag_list <- tags[,c("serial_number", "vue_tag_id", "code_space", "vue_id")]
    }
  }

  # Baseline tag validation checks
  # The main rule is: either the serial number OR the vue_tag_id must be provided.
  if (nrow(aa[is.na(aa$tag_serial) & is.na(aa$vue_tag_id),]) > 0) {
    #warning(nrow(aa[is.na(aa$tag_serial) & is.na(aa$vue_tag_id),]), " records have a NULL tag_serial AND vue_tag_id. These records cannot be entered into the database.")
    bad_records <- aa[is.na(aa$tag_serial) & is.na(aa$vue_tag_id),]
    for (i in 1:length(bad_records)) {
      errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "tag_serial & vue_tag_id", "Missing both tag_serial AND vue_tag_id. One or the other MUST be provided. These records cannot be entered into the acoustic_animals database table otherwise. Information about the animal can still be stored in metadata_animals, however.")
    }
  }

  if (nrow(aa[is.na(aa$tag_serial) & !is.na(aa$vue_tag_id),]) > 0) {
    #warning(sum(is.na(aa$tag_serial)), " records have NA serial numbers.")
    bad_records <- aa[is.na(aa$tag_serial) & !is.na(aa$vue_tag_id), c("animal_tag")]
    for (i in 1:length(bad_records)) {
      errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "tag_serial", "Missing tag serial number. Not required if vue_tag_id is provided, but highly recommended.")
    }
  }

  if (nrow(aa[!is.na(aa$tag_serial) & is.na(aa$vue_tag_id) & is.na(aa$vue_id),]) > 0) {
    #warning(sum(is.na(aa$vue_tag_id)), " records have NA Vue tag IDs.")
    bad_records <- aa[!is.na(aa$tag_serial) & is.na(aa$vue_tag_id) & is.na(aa$vue_id), c("animal_tag")]
    for (i in 1:length(bad_records)) {
      errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id & vue_id", "Missing vue_tag_id (e.g. 'A69-9001-9374') and vue_id ('9374'). Neither is required if serial number is provided, but highly recommended. If you do not know the full code space (e.g. 'A69-9001'), providing simply the vue_id (e.g., '9374') is helpful.")
    }
  }

  # Flag if any tags are duplicated
  # Duplicated serial numbers
  if (any(table(aa$tag_serial)>1)) {
    dupes <- data.frame(table(aa$tag_serial))
    dupes <- dupes[dupes$Freq > 1,]
    for (i in 1:nrow(dupes)) {
      dupes_sn <- dupes[i,1]
      bad_records <- aa[["animal_tag"]][aa$tag_serial == dupes_sn]
      errors[nrow(errors)+1,] <- c("acoustic_animals", toString(bad_records), "tag_serial", paste("Tag serial", dupes_sn, "duplicated."))
    }
  }

  # Duplicated vue_tag_ids
  if (any(table(aa$vue_tag_id)>1)) {
    dupes <- data.frame(table(aa$vue_tag_id))
    dupes <- dupes[dupes$Freq > 1,]
    for (i in 1:nrow(dupes)) {
      dupes_sn <- dupes[i,1]
      bad_records <- aa[["animal_tag"]][aa$vue_tag_id == dupes_sn]
      errors[nrow(errors)+1,] <- c("acoustic_animals", toString(bad_records), "vue_tag_id", paste("Vue tag ID", dupes_sn, "duplicated."))
    }
  }

  # More complex tag checks
  # Set text to indicate which data vetting sources were used for messages
  tag_src <- if (missing(tags) & !missing(db)) {
    "database"
  } else if (!missing(tags) & !missing(db)) {
    "provided 'tags' dataframe or the database"
  } else if (!missing(tags) & missing(db)) {
    "provided 'tags' dataframe"
  }

  # Check if both 'db' and 'tags' args are missing
  # If one or the other was provided, continue tag data validation
  if (missing(db) & missing(tags)) {

    # This is done in a more sophisticated way below if db or tags provided
    if (nrow(aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial),]) > 0) {
      missing_full_tag_id <- aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial),]
      message(nrow(missing_full_tag_id), " record(s) have a vue_id and tag_serial, but not a full vue_tag_id (e.g. 'A69-9001-9285'). Running fill_tag_id() could help fill those in automatically.")
      bad_records <- missing_full_tag_id[["animal_tag"]]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id", "Missing full vue_tag_id (e.g. 'A69-9001-9375'). Running fill_tag_id() could help fill this in automatically.")
      }
    }
  } else {
    # Now run any advanced tag-related data checks

    # Check that the tag serial numbers & vue IDs are actually in tag_list
    bad_sns <- aa[["tag_serial"]][!(aa$tag_serial %in% tag_list$serial_number) & !is.na(aa$tag_serial)]
    bad_vue <- aa[["vue_id"]][!(aa$vue_id %in% tag_list$vue_id) & !is.na(aa$vue_id)]
    bad_vue_id <- aa[["vue_tag_id"]][!(aa$vue_tag_id %in% tag_list$vue_tag_id) & !is.na(aa$vue_tag_id)]

    # Tag serial NOT in tag_list but vue id IS
    if (nrow(aa[aa$tag_serial %in% bad_sns & !(aa$vue_id %in% bad_vue),]) > 0) {
      bad_records <- aa[aa$tag_serial %in% bad_sns & !(aa$vue_id %in% bad_vue),]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "tag_serial", paste0("Tag serial ", bad_records[i,"tag_serial"], " is likely a typo. This tag is not present in the ", tag_src, " but full vue_tag_id exists. The function find_tag_errors() can help resolve any typos."))
      }
    }

    # Tag vue_id NOT in tag_list but serial IS
    if (nrow(aa[!(aa$tag_serial %in% bad_sns) & aa$vue_id %in% bad_vue,]) > 0) {
      bad_records <- aa[!(aa$tag_serial %in% bad_sns) & aa$vue_id %in% bad_vue,]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "vue_id", paste0("Vue ID ", bad_records[i,"vue_id"], " not present in the ", tag_src, " but serial number exists. Tag Vue ID is likely a typo. The function find_tag_errors() can help resolve any typos."))
      }
    }

    # Tag serial and vue ID are both in database, but vue_tag_id is not
    if (nrow(aa[!(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue) & aa$vue_tag_id %in% bad_vue_id,]) > 0) {
      bad_records <- aa[!(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue) & aa$vue_tag_id %in% bad_vue_id,]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "vue_tag_id", paste0("Code space typo in ", bad_records[i,"vue_tag_id"], " but valid tag_serial-vue_id combo. The function fill_tag_id() can fill in the full tag ID with the correct code space."))
      }
    }

    # Neither tag serial nor vue id in tag_list = missing or bad tag data
    if (nrow(aa[aa$tag_serial %in% bad_sns & aa$vue_id %in% bad_vue,]) > 0) {
      bad_records <- aa[aa$tag_serial %in% bad_sns & aa$vue_id %in% bad_vue,]
      for (i in 1:nrow(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i,"animal_tag"], "tag_serial & vue_id", paste0("The tag_serial-vue_id combination of ", bad_records[i,"tag_serial"], " & ", bad_records[i,"vue_id"], " does not exist. Either both are incorrect or new tag sheets need to be imported."))
      }
    }

    # Tag serial and vue ID are both in database, but vue_tag_id is empty
    if (nrow(aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial) & !(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue),]) > 0) {
      missing_full_tag_id <- aa[is.na(aa$vue_tag_id) & !is.na(aa$vue_id) & !is.na(aa$tag_serial) & !(aa$tag_serial %in% bad_sns) & !(aa$vue_id %in% bad_vue),]
      message(nrow(missing_full_tag_id), " record(s) have a valid vue_id and tag_serial, but not a full vue_tag_id (e.g. 'A69-9001-9285'). Running fill_tag_id() could help fill those in automatically.")
      bad_records <- missing_full_tag_id[["animal_tag"]]
      for (i in 1:length(bad_records)) {
        errors[nrow(errors)+1,] <- c("acoustic_animals", bad_records[i], "vue_tag_id", "Missing full vue_tag_id (e.g. 'A69-9001-9375'). Running fill_tag_id() could help fill this in automatically.")
      }
    }

    if (length(bad_sns) + length(bad_vue) + length(bad_vue_id) > 0 & length(bad_sns) < 10) {
      message("Some of your tag serial numbers and/or Vue ID codes and/or full tag IDs cannot be matched to an existing tag in the ", tag_src, ". This could be due to a typo in either the serial number or the vue id. The function `find_tag_errors()` could potentially help resolve any issues.")
    } else if (length(bad_sns) >= 10 & !missing(db)) {
      message("More than 10 of your records contain tag serials that are missing from the ", tag_src, ". This most likely means you need to find the associated tag sheets for these tags. Re-try validation after running `prep_tag_sheets()` on the new tags and providing the output to this function.")
    } else if (length(bad_sns) >= 10 & missing(db)) {
      message("More than 10 of your records contain tag serials that are missing from the ", tag_src, ". Try re-running the validation with an active database connection to check if these tags are already in the database.")
    }

  }

  if (nrow(errors) > 0) {
    return(tibble::as_tibble(errors))
  } else {
    message("Hooray! Your data passes all validation checks.")
  }

}


#' Fill in full Vue Tag ID
#'
#' @description If you have empty `vue_tag_id` values in your
#' `acoustic_animals` dataframe, you can use `fill_tag_id` to
#' find and populate `vue_tag_id` using the `vue_id` and
#' `tag_serial` columns. Any existing `vue_tag_id` values are
#' not modified.
#'
#' @details Each complete tag ID (e.g., 'A69-9001-3945') has a unique
#' Vue ID and tag serial. Provided you have the Vue ID and serial
#' number, in addition to the original tag purchase sheets, you
#' can easily look up the complete tag ID.
#'
#' @param dat A dataframe of `acoustic_animals` data; typically from the output of `prep_otn_tagging`.
#' @param tags A dataframe of `metadata_acoustictags` data that is not yet in the database to supplement tag lookups; typically the output of `prep_tag_sheet`.
#' @param db Name of SOMNI database connection object in R workspace. Defaults to "db".
#' @param overwrite Should the vue_tag_id column be overwritten? By default, only NULL vue_tag_id records are updated. Change to `overwrite = TRUE` to update all tags in the vue_tag_id column.
#'
#' @return A dataframe that matches the input `dat` dataframe, but with the `vue_tag_id` column populated.
#' @export
#'
#' @examples
#' tm <- readxl::read_excel("OTN_tagging_sheet.xslx", sheet = "Tag Metadata")
#' prepped_otn <- prep_otn_tagging(tm, db = db)
#' fill_tag_id(prepped_otn$acoustic_animals, db = db)
fill_tag_id <- function(dat,
                        tags = NA,
                        db = db,
                        overwrite = F) {
  aa <- dat
  if (missing(tags) & missing(db)) stop("This function must be provided tag sheets or a database connection to function.")

  # If db connection provided, pull all tag info
  if (!missing(db)) {
    tag_list <- DBI::dbGetQuery(db, "select serial_number, vue_tag_id from metadata_acoustictags;")
    x <- sapply(tag_list$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tag_list$vue_id <- x[2,]
  }

  # If database connection was provided AND tags dataframe provided,
  # merge the two vetting dataframes together
  if (!missing(tags)) {
    x <- sapply(tags$vue_tag_id, function(x) strsplit(sub("(-)(?=[^-]+$)", " ", x, perl = T), " ")[[1]], USE.NAMES = F)
    tags$vue_id <- x[2,]
    if (!missing(db)) {
      tag_list <- rbind(tag_list, tags[,c("serial_number", "vue_tag_id", "vue_id")])
    } else {
      tag_list <- tags[,c("serial_number", "vue_tag_id", "vue_id")]
    }
  }

  names(tag_list)[1] <- "tag_serial"

  if (overwrite) {
    aa$vue_tag_id <- NA
    fill <- aa[["animal_tag"]][!is.na(aa$tag_serial) & !is.na(aa$vue_id)]
  } else {
    fill <- aa[["animal_tag"]][is.na(aa$vue_tag_id) & !is.na(aa$tag_serial) & !is.na(aa$vue_id)]
  }

  tag_ids <- merge(aa[aa$animal_tag %in% fill, c("animal_tag", "vue_id", "tag_serial")], tag_list, by = c("tag_serial", "vue_id"))

  aa[["vue_tag_id"]][match(tag_ids$animal_tag, aa$animal_tag)] <- tag_ids$vue_tag_id
  message("Updated ", nrow(tag_ids), " vue_tag_id records!")
  return(aa)
}
